\documentclass[11pt,a4paper,final,notitlepage]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{url}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}

\usepackage{stackengine,graphicx,trimclip,scalerel}

\renewcommand{\baselinestretch}{1.25} %Increase 

\makeatletter
\newcommand*{\toccontents}{\@starttoc{toc}}
\makeatother

\newcommand{\noNumberChapter}[2]{
    \setcounter{chapter}{#1}
    \setcounter{section}{0}
    \chapter*{#2}
    \addcontentsline{toc}{chapter}{#2}
}

\usepackage[nopar]{lipsum}
\usepackage{stackengine,graphicx,trimclip,scalerel}
\savestack\eye{\rotatebox{90}{$^\circ\mkern-6mu\raisebox{1pt}{)}$}}
\savestack\nose{\raisebox{3pt}{\scalebox{1}[-1]{\clipbox{0pt 1pt 0pt 0pt}{?}}}}
\savestack\mouth{\rotatebox{90}{(}}
\newcommand\Lenny{(\scalerel{\stackanchor[2pt]{\eye \nose \eye}{\mouth}}{)}}


\begin{document}

\title{ Major Project Report }

\author{ Tom Minor - Level H\\
		Major Project\\
		Bournemouth University - NCCA}

\maketitle

\renewcommand{\abstractname}{Project Overview \Lenny{}}
\begin{abstract}

\textit{Main Aspects}
\begin{enumerate}
\item Fractal Renderer
\item FX Work
\item Pipeline
\end{enumerate}

\end{abstract}

\toccontents


\noNumberChapter{1}{Initial Research}
\section{Trying out existing stuff}


\subsection{Fractals in FX Software}

Looked at developing fractals in Houdini, may not need to develop a custom tool to visualise

Volumetric mandelbulb

Voxel Based

Slow to compute

%\lstset{language=C++, 
%		keywordstyle=\color{blue}}
%\begin{lstlisting}
%int iter = chi("iterations");
%int n = chi("n");
%float limit = chf("limit");
%
%vector Z = ptransform("space:current", "space:object", @P);
%
%for(int i = 0; i < iter; i += 1)
%{
%    /// Convert to spherical coords ///
%
%    // Precompute component squares
%    float xpow = Z.x * Z.x;
%    float ypow = Z.y * Z.y;
%    float zpow = Z.z * Z.z;
%    
%    // Spherical coords = (r, theta, phi)
%    float r = sqrt(xpow + ypow + zpow);
%    float theta = atan2(sqrt(xpow + ypow), Z.z);
%    float phi = atan2(Z.y, Z.x);
%    
%    /// Exponentiation term (raise {x,y,z} to nth power) ///
%    // 
%    /* -> simplified form
%       {x,y,z}^n = r^n { sin(theta*n) * cos(phi*n), 
%                         sin(theta*n) * sin(phi*n), 
%                         cos(theta*n) }
%                         
%       -> expanded form
%       {x,y,z}^n = { r^n * sin(theta*n) * cos(phi*n), 
%                     r^n * sin(theta*n) * sin(phi*n), 
%                     r^n * cos(theta*n) }
%    */
%    float tmpPow = pow(r, n);
%    float tmp = tmpPow * sin(theta * n);
%    
%    vector newZ = set(  
%        tmp * cos(phi * n),
%        tmp * sin(phi * n),
%        tmpPow * cos(theta * n)
%    );
%   
%    
%   
%    Z += newZ;
%}
%
%if( length(Z) < limit) {
%    @density = 1.0;
%} else {
%    @density = 0.0;
%}
%\end{lstlisting}

\begin{center}
\includegraphics[scale=0.2]{"images/houdini_mandelbulb"}
\end{center}

Disney used houdini on BH6, but it's much too slow for our needs.

Need a custom tool

Houdini is still good for creature effects though, example noise shader goes here



\section{Reading the documentation and tutorials}

\noNumberChapter{2}{Pipeline}

\begin{itemize}
	\item Dropbox isn't enough
	\item Need to version
	\item More effort at beginning of the project, having backups of every asset could save our asses in the end
	\item use perforce
	\item Other scripts can be added to the main pipeline suite
	\item Referencing pipeline required custom hooks that modify all referenced paths to be relative to \$CONTACTROOT, automated, idiot proof
	\item Referencing in 10 files and manually clicking student popup is tedious, on save and submit remove student/education flags
	\item Forces the team to think in a collaborative way, they literally cannot work on the same asset at the same time
	\item Took some getting used to, but now the artists are used to version control and it's benefits even if it's tedious at times
	\item Main development time spent on PySide Qt GUI stuff, after the initial time spent learning the P4 API and commands
	\item Technically cross application, the P4 and GUI side of things will work whereever pyside is available. Needs a few app specific tweaks such as file saving commands etc to work properly but wouldn't take long to port
	\item Various wizards to automate asset/shot/lookdev file structure generation because kyran made the layout super complex
	\item 
\end{itemize}

\noNumberChapter{3}{Renderer}

\begin{itemize}
	\item How best to make this artist friendly (Nodegraph)
	\item What technique (ray marching)
	\item Use Optix because it's faster than what i can do
	\item Nodegraph needs runtime compilation, at least for geo
	\item Does require a little hacking to get runtime code generation
	\item Use NVRTC to compile code at runtime and plug into preexisting functions in the optix code
	\item Use hacky system commands to call nvcc directly if using CUDA 6.5 or less, aka, the uni systems
	\item Initial dev time for node graph, runtime compilation etc is long, but in theory will allow for rapid iteration once it works
	\item Everything is based on demo scene stuff, can use shadertoy as reference for loads of effects
	\section{Scene Management - Code Reflection}
		Need to change scene based on node graph
	\subsection{PTX Patching}
		\begin{itemize}
			\item Initial attempt, required research into the .ptx format
			\item Use NVCC to compile CUDA program into ptx code and patch into the Optix ptx code, then load into Optix
			\item Works on my machine and university workstations, but potentially undefined behaviour and not officially supported
			\item Relies on my own string handling functions
		\end{itemize}
	\subsection{Optix Callable Programs}
		\begin{itemize}
			\item Discovered this later in the project after reading the Optix documentation fully, initially didn't notice what it was because it's not used very often compared to the other aspects of optix and isn't really clear unless you know what it does.
			\item Use NVCC to compile CUDA program into ptx code and then tell Optix to use this as a 'callable program', basically replacing the ptx patching process with a well defined, built in functionality.
			
		\end{itemize}
\end{itemize}


\noNumberChapter{4}{Conclusion}

\nocite{*}

\bibliographystyle{plain-annote}
\bibliography{bib_icereport}
\end{document}
